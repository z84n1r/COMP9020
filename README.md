java c
COMP9020 
Assignment 3 – Guide 
2024 Term 1
Due: Thursday, 4th April, 18:00 (AEDT) 
Submission is through inspera. Your assignment will be automatically submitted at the above due date.   If   you manually submit before this time, you can reopen your submission   and   continue   until   the   deadline.    If   you   need to   make a submission after the deadline,    please use this link to request an extension: https://www.cse.unsw.edu.au/   cs9020/extension_request.html. Unless you   are   granted   Special   Consid-   eration,   a lateness penalty of 5% of   raw   mark   per   24   hours   or   part   thereof   for   a   maximum   of   5   days   will   apply.   You can request an extension up   to   5   days   after   the   deadline.
Answers are expected to   be provided   either:
•    In the text box provided using plaintext, including unicode characters and/or the built-in formula   editor (diagrams can be drawn using the built-in drawing   tool);   or 
•    as   a   pdf   (e.g.    using   LATEX)   –   each   question   should be   submitted   on   its   own   pdf,   with   at   most   one   pdf per question. 
Handwritten   solutions   will   be   accepted   if   unavoidable,   but   we   don’t   recommend   this   approach   as   the   assessments   are   designed   to   familiarise   you   with   typesetting   mathematics   in   preparation   for   the   final   exam and for   future   courses. 
Discussion of assignment material with others is permitted, but the work   submitted must be   your   own   in   line with the University’s plagiarism policy.
Objectives and Outcomes The   aim   of   this   assignment   is   to   build   your   understand   of   recurrence,   induction   and   the   asymptotic   analysis   of   algorithms.      Most   questions   are   presented   at   a   highly   abstract   level   so   that   the   consequences   are   very   general,   and   can   be   applied   in   a   variety   of   situations:      not just   later   on   in   the   course,   but   also   beyond.   The specific motivation for each problem can be summarised   as   follows:
Problem 1: This   question   looks   at   the   complexity   of   three   algorithms   for   various   matrix   operations   –   two   iterative   algorithms   for   matrix   addition   and   multiplication   and   one   recursive   algorithm   for   matrix multiplication.   This recursive algorithm takes the first steps towards the Strassen Algorithm for matrix multiplication.    In   that   algorithm,   the   recursive   submatrices   (SW + TY,   etc)   are   cleverly   computed via   a   different   set   of   intermediate   matrix   calculations   (e.g.    one   step   is   to   calculate   (S +   V)(W + Z))   rather   than   the   more   direct   approach   we   take   here.    The   Strassen   Algorithm   is   also   closely related to the Karatsuba algorithmfor integer multiplication – an elementary form. of this is   taught in primary school as the Box   method. 
Problem 2: In this question   you   are   asked   to   work   on   a   series   of   identities   of   gradually   increasing   com-   plexity.   The aim is to practice applying basic   induction on algebraic expressions to prove properties   of the natural numbers.
Problem 3: This   question   introduces   a   commonly   used   recurrent   structure   used   in   computer   science,   binary trees.   The question will guide you through how you define a recursively defined mathemat-   ical structure along with functions on that structure,   and how   to   use   structural   induction   to   reason   about such structures and   functions.
Problem 4: In   this   question you will   be   tested   on   your   ability   to   solve   a   recurrence   relation   asymptoti-   cally.   The goal is to test your ability to reason about asymptotic growths   beyond the master theorem,   and use the idea of asymptotics to solve   relations   that   might be   difficult   to   solve   exactly.
After completing this assignment, you will:
•    Be able to make rigorous arguments about the foundational structures used in discrete mathematics   [All problems, particularly   1 and 3]
•    Understand the fundamental Computer Science concepts of   recursion and induction [All problems]
•    Analyze the correctness and efficiency of algorithms   [Problem   1   and   4]
Specific advice on how to do this assignment 
Problem 1 
•   For   Question   1,   you   are   asked   for   asymptotic   upper   bounds.    You   should   aim   to   give   the   best   upper   bound   you   can   derive   as   this   indicates   your   level   of   ability   and   understanding.         Sub-   optimal upper   bounds may still   be eligible for full marks if   optimisations   fall   outside   the   expected   knowledge   of   the   course;   but   sub-optimal bounds   where   there   is   a   reasonable   expectation   that   students can find improvements will only be eligible for partial marks.
• As an example, recall the following algorithm outline for insertionSort   from lectures:
sort(L) :
if   L.isEmpty()   :
return         L   else   :
L2 := sort(L.next)               insert         L.data   into         L2   return   L2
In particular, the line:
insert         L.data   into         L2
If you were asked to provide an   asymptotic   upper bound   for   the   running   time   of   this   line,   then   an HD-level answer eligible for full marks   might be:To insert L.data into L2   we   could   iterate   through   L2,   comparing   each   element   of   the   list   with L.data, until we find the correct place to insert it.   In the worst case this will   require   checking   every   element   of   L2, which   means   at   most   n   −   1   = O(n) comparisons.   Therefore an upper bound on the running time for this line would be O(n).Note that   since   L2 is   sorted,   it is possible   to   use binary   search to   find   the   correct   place   to   insert   L.data,   and   this   gives   a   solution   that   will   only   require   O(log   n)   comparisons.      So   the   upper   bound   of   O(n)   is   sub-optimal;   however   as   we   don’t   assume   knowledge   of   binary   search,   the   well-reasoned solution given above would be eligible for full marks.
•   As always, it is recommended that you justify your answer.   For parts a) and b)   a   sensible way   to   show how you obtain the running time would be to use the process used in lectures – calculating   the running time   of each individual   line   and   combining   them   alltogether.    Textual   descriptions   for non-trivial running times are a good   idea.   It   is   also   a   good   idea   to   annotate   the   algorithm   to   assist with referencing.   Again, taking the   example above, here is an HD-level answer calculating   the recurrence relation for the running time of   that   algorithm:
sort(L) :
if   L.isEmpty()   :
return         L   else   :
L2 := sort(L.next)               insert         L.data   into         L2   return   L2
Let the running time of the above algorithm   on   a list   of   length   n   be   T(n).   Then:
– Lines   1,   2   and   6   consist   of   a   constant   number   of   elementary   operations,   so   have
running time O(1)   (as indicated)
– Line 4 involves a recursive call to   sort with a   list   of length   n   −   1.   So   it   has   running   time   T(n −   1).
– Line   5 has   running   time   O(n) as   discussed   above.
– The   “if”   part   is   only   executed   when   L   is   the   empty   list   (i.e.    when   n   =   0);   for   all   other n only the   “else”   part   is   executed.
Putting this all together gives the following   recurrence relation for   the   running   代 写COMP9020 Assignment 3 – Guide 2024 Term 1SQL
代做程序编程语言time:   T(0) = O(1)                                     T(n) = O(1) +   O(n) + T(n −   1) = T(n −   1) +   O(n).In   inspera,   the   algorithms   in   the   question   are   presented   in   tables.    Copying   and   pasting   the   algorithms   from   the   question   to your   solution will   give you   the   algorithm in   a   table   form. making annotation easier
•   For part c) you are only provided with a description of the algorithm idea.   To provide a   justifica-   tion for your recurrence it is sufficient to identify what parts of the algorithm   are contributing to   the running time and what their algorithmic cost is.   When the algorithm description is informal,   you may have to workout a way to fill in   some   missing   steps   (e.g.   the   insert   example   above) but   if this is necessary, a simple/obvious   approach is   acceptable.
Remark
The recursive   algorithm takes the first   steps   towards   the Strassen   Algorithm for   matrix   multi-   plication.   In that algorithm, the recursive submatrices (SW + TY, etc) are cleverly computed via   a   different   set   of   intermediate   matrix   calculations   (e.g.   one   step   is   to   calculate   (S + V)(W +   Z))   rather than the more direct   approach we   take   here.
Problem 2 
•   The problem encourages you to   follow   the   typical   layout   for   an   inductive   proof.    You   are   asked   to   prove   P(n),   Q(n) and   R(n) for   all   n   ∈ N.    To   do   so   follow   find   an   appropriate   base   case,   for which proving the identity should be fairly simple, and then show that   P(n)      =⇒   P(n + 1).
•   You   will   probably   want   to   do   the   questions   in   order,   as   the   answers   found   in   the   previous   questions allow you to simplify the sums you will be working within the subsequent ones.   This   is however not strictly necessary.
•   There are multiple ways you can rearrange   the   sums   you   will   obtain.   In   particular,   for   question   b),   you   may   use   the   answer   obtained   in   question   a)   but   it   is   also   possible   that   you   can   take   another   route.      It   might   be   of   use   (in   particular   for   question   c)   to   use   the   following   identity (derived in the lectures starting from 0): ∑in=1i =n(n2+1). 
•   The   goal   of   the   question   is   to   familiarise   yourself   with   basic   induction.    Although   you   do   not   strictly need to use induction, and will get full marks for a non-inductive   proof,   you   are   encour-   aged   to   think   about   how   you   would   use   induction   to   work   on   such   a   problem,   and   how   the   proofs might differ whether you use induction   or   not.   Often   induction   makes   it   simpler   to   find a   formal   proof,   however   you   might   find   that   using   a)   to   prove   b)   without   using   induction   is   somewhat simpler.
•   If   you   approach   a   question   inductively,   but   find   that   you   did   not   make   use   of   your   inductive   hypothesis in your inductive step, then you are not actually using   induction,   so   you   might   want   to reframe. your proof as a non-inductive proof.
Problem 3 
•   The abstract definition of a binary tree is similar to the abstract definition of a linked list – except   we   have   two   “tails”,   and   no   data   item   in   the   head.    Visually,   it   may   be   useful   to   think   of   the   recursive case   as:
•   An   implementation   of   the   functions   count,   leaves   and   internal   in   the   programming   language   of   your   choice,   rather   than   as   an   abstract   mathematical   function,   is   acceptable   and   will   not   incur   any penalties.   However, such an answer for (b) and (c) will make it almost impossible to provide   a   suitable   answer   for   part   (d)   (see   comments   below).
•   Here   are   two   examples   of   recursively   defined   functions   for   computing   the   length   of   a   linked   list,   and   concatenating   two   linked   lists   (compare   to   the   definition   given   in   lectures   of   similar   functions for words):
•   For a distinction level answer or higher, a short (one or two sentence)   justification   for   correctness   is expected.   Here is an example of an HD-level answer   giving   a   recursive   definition   for   comput-   ing the height of a binary tree:   the length of the longest path from   the root to a leaf (and defined   to   be   −1 for   the   empty   tree):
•   Instead   of   providing justification   as   above,   it   may   be   worth   checking   your   answer   against   the   example   tree   given   in   the   assignment   description.    Indeed,   such   a   check   would   demonstrate   a   level   of   understanding   expected   of   a   credit-level   student,   so   partial   marks   are   available   for   a   check like the following:
•   Even   though   the   recursive   definition   of binary   trees   consist   of   one base   case   and   one   recursive   case,   some   of   the   functions   in   parts   (a)–(c)   involve   other   cases:    in   particular    additional   base   cases/special cases of the recursive case   (it is not   important which   category   it   falls   under).
•   Part   (d)   is   about   proving   the   specified   relationship between the functions you have defined,   it   is not   about   showing   a particular property   of binary trees   (i.e.    that the number   of   leaves   is   one   more   than   the   number   of   fully-internal   nodes).    In   particular,   your   proof   should be   relying   on   the definitions of   leaves and   internal provided in parts   (b)   and   (c)   [and the   recursive   definition   of   binary   trees   on which   these   are based].    An   induction proof based   on   “the number   of   nodes   in   the   tree”   is   unlikely   to be proving   the   correct   result.    As we   are proving   a   result   for   an   infinite   set   of   structured   objects,   proof   by structural induction   is   a   recommended   approach.      Here   is   an   example   of an HD-level   structural induction proof   involving   the   functions   length   and   concat   defined above:
•   Note that when using structural induction, the induction hypothesis is that the proposition holds   for all smaller structures required to   construct   the   complex   structure.   For   example,   when   trying   to prove P(T) when   T   =   (Tleft, Tright) the standard inductive step would be to show:
If P(Tleft) and P(Tright) both hold, then P(T) holds.
Problem 4 
•   In this problem you are asked to find the asymptotic solution of a recurrence relation.   The master   theorem   works   when   you   have   a   single   recurrent   term   on   the   right-hand   side   of   the   equation,   however in this relation you have several recurrent terms with   different   coefficients.
•   A common way   of solving   such problems,   is   to   guess   the   solution   and   substitute   your   guess   in   the equation and   see   if   it holds.
•   Since you are only asked to   find   asymptotic   behaviour,   your   guess   doesn’t   need   to   worry   about   details such as the   exact   values   of   coefficients.
•   Here   is   an   example   of   how   you   might   analyse   the   asymptotic   growth   of   a   recurrence   relation   without using the master theorem:
•   This example gives you some indications as to   what   your   proof   should   look   like.   In   the   exercise   however you might have to be more careful as some   steps   might   not be   as   straightforward.




         
加QQ：99515681  WX：codinghelp
